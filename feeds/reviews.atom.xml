<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Programming for fun and profit - Reviews</title><link href="https://slar.se/" rel="alternate"></link><link href="https://slar.se/feeds/reviews.atom.xml" rel="self"></link><id>https://slar.se/</id><updated>2023-10-14T00:00:00+02:00</updated><subtitle>A blog about software engineering, programming languages and technical tinkering</subtitle><entry><title>Book Review: Writing an Interpreter in Go</title><link href="https://slar.se/book-review-writing-an-interpreter-in-go.html" rel="alternate"></link><published>2023-10-14T00:00:00+02:00</published><updated>2023-10-14T00:00:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2023-10-14:/book-review-writing-an-interpreter-in-go.html</id><summary type="html">&lt;p&gt;I love programming languages, both using them and implementing them. As such, I
found the concept of learning Go by creating a programming language to be just
delightful. And, to put it briefly, it was. Let's talk about Thorsten Ball's
book on interpreters. In Go.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Writing&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;an&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Interpreter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Go …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;I love programming languages, both using them and implementing them. As such, I
found the concept of learning Go by creating a programming language to be just
delightful. And, to put it briefly, it was. Let's talk about Thorsten Ball's
book on interpreters. In Go.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Writing&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;an&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Interpreter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Go&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thorsten&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Ball&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nl"&gt;Publisher&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Thorsten&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Ball&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nl"&gt;ISBN&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9783982016115&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;You can buy the book directly from Thorsten Ball's website at
&lt;a href="https://interpreterbook.com/"&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;The book in a nutshell&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Writing an Interpreter in Go&lt;/em&gt; is precisely what it sounds like; a practical
guide to writing a fully functioning interpreter in Go. You go from source
code, to tokens, to abstract syntax tree and tree evaluation. The parser
is based on the pretty fascinating
&lt;a href="https://en.wikipedia.org/wiki/Operator-precedence_parser#Pratt_parsing"&gt;&lt;em&gt;Pratt parsing&lt;/em&gt;&lt;/a&gt;
technique, while the evaluation is based on simple tree-walking. This relative
simplicity allows Ball to cram a whole lot of functionality into a very concise
200 pages worth of book. The result is impressive, and I am somewhat astonished
by just how much content is actually in here, and how well written said content
is.&lt;/p&gt;
&lt;h1&gt;What I liked&lt;/h1&gt;
&lt;p&gt;There is so much to like about this book. First of all, it is wonderfully
standalone. I wrote around 3500 lines of code based entirely on descriptions
and code samples from the book's 200 printed pages. Although the source code
for the interpreter is available as part of the book, I never needed to
reference it.&lt;/p&gt;
&lt;p&gt;Something else I just barely needed to reference was documentation for Go
itself. While this book doesn't teach you programming and is therefore not for
complete beginners, it does somewhat teach you Go by example. There are little
to no explanations for how Go works, but due to how simple Go is I think the
examples speak for themselves. A caveat to that is that I have done some Go
programming in the past, and I think that a complete beginner to Go should
probably go through the interactive &lt;a href="https://go.dev/tour/"&gt;A Tour of Go&lt;/a&gt;
tutorial first. The only thing that I personally needed to reference was some
details around how interfaces and &lt;code&gt;nil&lt;/code&gt; work together in Go (it's &lt;a href="https://go.dev/doc/faq#nil_error"&gt;really quite
unintuitive&lt;/a&gt;). It should also be noted that
there is nothing about concurrency in this book, which being a major selling
point of Go entails that this book omits some important parts of the language.
I do however find that completely reasonable given the scope of the book.&lt;/p&gt;
&lt;p&gt;The book is also for the most part organized in a way that fit me very well.
In the first few parts of the book, the implementation is given up front and
then tests are added to verify the behavior. The majority of the later parts of
the book are however laid out in the opposite order, with descriptions of
functionality and tests being followed by the actual implementation. This
allowed me to read the tests and the descriptions to get a good idea of the
intended behavior, and then try my own hand at coming up with a solution.
Comparing my solution to the author's after the fact was a great way to cement
the knowledge.&lt;/p&gt;
&lt;p&gt;The source code exhibits a splendid balance between proper design and being
simple enough to put into a book this short. There were several design decisions
that I did not fully agree with, especially with the parsing of strings, but I
can also see that certain simplifications had to be made to fit the format. For
the most part, I think these simplifications are well chosen.&lt;/p&gt;
&lt;p&gt;Concepts are explained clearly and intuitively. Pratt parsing is by far the most
involved topic in the book, and I think Ball presents it in a very digestible
fashion. I needed to run through it a couple of times and mentally step through
the code, but when it clicked I found no fault in how the concepts were
explained. At no point did I need to reference external sources to understand
something.&lt;/p&gt;
&lt;p&gt;The last part of the book adds in a few extra features, such as arrays and hash
maps. All of these extra features are implemented in a very satisfying loop,
going all the way from the lexing to the finished evaluation in one short
chapter for each feature. Adding one feature at a time in this way really aids
in understanding the workings of each part of the interpreter. And that, in
fact, is a perfect segue to the one part of this book that I did not entirely
like.&lt;/p&gt;
&lt;h1&gt;What I didn't like&lt;/h1&gt;
&lt;p&gt;I actually started this book around five years ago, but never finished it. In
fact, I got just barely halfway due to what I perceive as the one flaw of this
otherwise fantastic piece of literature: it has a rather slow start. It's not
until halfway through that you actually get to evaluation and thereby create a
complete path from source code to output. The fantastic pacing of the last
quarter of the book where you add features one at a time highlights that the
first half isn't as satisfying as it probably could be. While I recognize that
the amount of groundwork to put down before getting to the exciting parts is a
tough one to make, I think the book would have been better off closing the path
from source code to evaluation earlier. For instance, I don't see any need to
parse function definitions before evaluating arithmetic expressions.&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;This is a great book. It's clear, concise and packed full of learnings. Due to
the way the last quarter of the book is laid out, adding feature upon feature
from start to finish, I was able to quite effortlessly add features completely
of my own design by the time I finished the book. The only complaint I have
about the book is that not more of it is laid out in that fashion, because it's
just so good.&lt;/p&gt;
&lt;p&gt;If you've dipped your toes in Go and want an exciting project to learn the
language better, I think this is a great way to do it. It takes a little while
before the book gets going for real, but when it does, it really takes off.&lt;/p&gt;</content><category term="Reviews"></category><category term="book review"></category><category term="software engineering"></category><category term="go"></category></entry><entry><title>Book Review: CPython Internals</title><link href="https://slar.se/book-review-cpython-internals.html" rel="alternate"></link><published>2022-11-20T00:00:00+01:00</published><updated>2022-11-20T00:00:00+01:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2022-11-20:/book-review-cpython-internals.html</id><summary type="html">&lt;p&gt;About a month ago I signed myself up to do a talk at a Python meetup hosted by
&lt;a href="https://hiq.se/"&gt;HiQ&lt;/a&gt;. I brazenly set my topic as &lt;em&gt;Under the Hood of CPython&lt;/em&gt;,
thinking I had sufficient understanding of its inner workings to produce a
riveting talk. As I started preparing the talk …&lt;/p&gt;</summary><content type="html">&lt;p&gt;About a month ago I signed myself up to do a talk at a Python meetup hosted by
&lt;a href="https://hiq.se/"&gt;HiQ&lt;/a&gt;. I brazenly set my topic as &lt;em&gt;Under the Hood of CPython&lt;/em&gt;,
thinking I had sufficient understanding of its inner workings to produce a
riveting talk. As I started preparing the talk, I came to the gut-wrenching
conclusion that my knowledge was too shallow, I simply didn't know enough of
the details to put together an in-depth talk on the subject. Thankfully, I knew
where to turn to for the details I needed: Anthony Shaw's &lt;em&gt;CPython Internals&lt;/em&gt;
book. Here's what I think of it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;CPython Internals
by Anthony Shaw
Released May 2021
Publisher(s): Real Python (realpython.com)
ISBN: 9781775093344
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;Confused about the difference between Python and CPython? See &lt;a href="https://slar.se/the-difference-between-python-and-cpython.html"&gt;The difference
between Python and
CPython&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;The book in a nutshell&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;CPython Internals&lt;/em&gt; gives you a guided tour of the CPython project, from
parsing source code to compiling bytecode to interpreting said bytecode. The
book is meant to serve as a starting point for budding CPython contributors or
Python developers that simply want to learn a bit more about the reference
implementation. It highlights the most important files in the project for each
of the respective parts and guides you through their execution. Throughout the
book we also get to follow along with a worked example of extending the language
with an "almost equal" operator, written as &lt;code&gt;~=&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The book concludes with three concrete ways in which you can use the knowledge
you've attained: 1) creating C extensions, 2) improving existing Python programs
by leveraging knowledge of the internals and 3) contributing to the CPython
project. While point 2) is potentially a little bit vague, points 1) and 3) are
concrete and well described.&lt;/p&gt;
&lt;p&gt;Before writing the book, Anthony wrote an in-depth article on the same topic.
You can find it over on &lt;a href="https://realpython.com/cpython-source-code-guide/"&gt;Real
Python&lt;/a&gt;. It is something of
an appetizer for the book, but stands strong on its own. Having a brief look at
that article will give you a better understanding of what the book is about
than anything I could write here.&lt;/p&gt;
&lt;h1&gt;What I liked&lt;/h1&gt;
&lt;p&gt;I went from surface-level understanding of the CPython project to being pretty
confident about where to poke around to do what just from reading this book.
It's comprehensive in scope and the worked example of the &lt;code&gt;~=&lt;/code&gt; operator helps &lt;em&gt;a
lot&lt;/em&gt; in facilitating an understanding for how to extend CPython with your own
silly things.&lt;/p&gt;
&lt;p&gt;I also appreciated the nods to other respectable sources. The &lt;a href="https://devguide.python.org/"&gt;Python
Developer's Guide&lt;/a&gt; is a great resource for quickly
refreshing how to do something (but going from 0 knowledge about the project
it's a bit to terse). Luciano Ramalho's book &lt;a href="https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/"&gt;Fluent Python 2nd
ed&lt;/a&gt; is
also noted as an excellent reference on the Python object model, which I
absolutely agree with.&lt;/p&gt;
&lt;p&gt;There is enough context in each chapter that you don't really need much
pre-existing understanding of any of the subjects. If you can read Python code
and have a little bit of experience with reading C code, you're all good to go.
Concepts relevant to the book such as parallelism and memory management are
explained both on an abstract level and in how they are implemented in CPython.
The book is to a great extent a standalone resource and it should be very
approachable even to developers without much experience. There's even an
appendix at the end to explain what little you need to know about the C
programming language to be able to understand the code samples.&lt;/p&gt;
&lt;h1&gt;What I didn't like&lt;/h1&gt;
&lt;p&gt;There was nothing about the book that I thought was &lt;em&gt;bad&lt;/em&gt;, but for me
personally, I would have preferred less explanation of fundamental concepts
(such as threading), and more in-depth details on CPython itself. That being
said, I think Anthony overall has made good calls on the tradeoffs between depth
and approachability. Given that the book is meant to be a starting point for
CPython development as opposed to a complete reference, I think that this
nit-pick of mine is nothing more than personal preference, and perhaps that I'm
slightly outside the target audience of the book. It's clearly meant to contain
everything you'd need to know to go from zero to hero, and it's a lot easier to
skip over content you feel is redundant than it is to find content you didn't
know you needed.&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;CPython Internals saved my neck. I had three weeks to go from a shallow
understanding of the CPython project to being able to explain it to others in a
~30-minute talk, and &lt;a href="https://github.com/slarse/talks/tree/80503786d4587abdadba9913c55c7d133269f3a2/under-the-hood-of-cpython"&gt;I made
it&lt;/a&gt;.
Without this book I wouldn't have. It was so approachable that I could use it
for "Sunday reading" before bedtime and in spare minutes on public transport.&lt;/p&gt;
&lt;p&gt;I highly recommend this book to anyone who's interested in the CPython project.
It's not necessary to have future CPython contributions as a goal to get a lot
out of this book, I found it incredibly interesting in its own right. The fact
that Anthony has managed to pack so much information, with so much context
(recall that I thought there was too much of that) in less than 400 pages is
nothing short of spectacular.&lt;/p&gt;</content><category term="Reviews"></category><category term="book review"></category><category term="software engineering"></category><category term="python"></category></entry><entry><title>Book Review: The Rust Programming Language</title><link href="https://slar.se/book-review-the-rust-programming-language.html" rel="alternate"></link><published>2022-08-10T00:00:00+02:00</published><updated>2022-08-10T00:00:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2022-08-10:/book-review-the-rust-programming-language.html</id><summary type="html">&lt;p&gt;I've been learning Rust on and off for the past few months, and &lt;em&gt;The Rust
Programming Language&lt;/em&gt; has been my &lt;a href="https://slar.se/learning-a-new-programming-language.html"&gt;primary learning
resource&lt;/a&gt; during this time.
It's a great introduction to the language, and is even &lt;a href="https://doc.rust-lang.org/stable/book/"&gt;freely available
online&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here, I'm reviewing the 2018 print version. Although a little bit …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've been learning Rust on and off for the past few months, and &lt;em&gt;The Rust
Programming Language&lt;/em&gt; has been my &lt;a href="https://slar.se/learning-a-new-programming-language.html"&gt;primary learning
resource&lt;/a&gt; during this time.
It's a great introduction to the language, and is even &lt;a href="https://doc.rust-lang.org/stable/book/"&gt;freely available
online&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here, I'm reviewing the 2018 print version. Although a little bit out of date by
now, there's nothing that's become obsolete, so I can still recommend even this
version. For the most up to date version, the online one is however the way to
go.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;The Rust Programming Language
by Steve Klabnik, Carol Nichols
Released June 2018
Publisher(s): No Starch Press
ISBN: 9781593278281
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;The book in a nutshell&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;The Rust Programming Language&lt;/em&gt; is really a book where the title perfectly
captures what the book is about. It teaches Rust mostly by practical examples,
and for the most part the examples are self-contained and executable. For some
concepts, examples are either missing or more illustrative than executable, but
these are few and far between.&lt;/p&gt;
&lt;p&gt;The book also to a large extent explains programming concepts, and has a rather
elaborate section on concurrency. It however isn't on a beginner level, and
doesn't go out of its way to intuitively describe what a variable is, or how
looping works. I would rate this a great book for someone who is already
somewhat familiar with programming concepts, but it's not the best resource for
getting started with programming as a whole. It's the perfect "second language
book".&lt;/p&gt;
&lt;h1&gt;What I liked&lt;/h1&gt;
&lt;p&gt;This book is incredibly well written and organized. Concepts to be learned are
first presented on a high level, and then the authors drill into the details.
But not too far into the details; at several points we are referred to other
resources to acquire a deeper understanding for certain concepts. It's also a
great standalone resource for learning Rust as it covers surrounding tooling
like &lt;code&gt;rustup&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt; in addition to the language itself. You can learn Rust
to a decent level of proficiency from this book alone.&lt;/p&gt;
&lt;p&gt;The well thought out pacing of the book carries over to the code samples, which
are excellent through-and-through. There are some rather tricky concepts to get
your head around in Rust compared to other programming languages, and the code
samples are crucial in getting the point across. These are also presented in a
top down fashion. By that, I mean that the higher level code is presented first
containing calls to yet to be defined functions that are presented later. &lt;/p&gt;
&lt;p&gt;As a crude example, imagine that we want to present a program that adds two
numbers and prints the result. That may look like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;{}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And then we define the &lt;code&gt;add&lt;/code&gt; function after having presented the high-level idea
we want to implement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;: &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;: &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="kt"&gt;i32&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This top down approach to presenting code samples really helps in getting a good
idea for &lt;em&gt;what&lt;/em&gt; needs to be done before &lt;em&gt;how&lt;/em&gt; it is actually implemented. I
strongly prefer this approach to a bottom up one, where you start with the low
level &lt;em&gt;how&lt;/em&gt; before getting to the high level &lt;em&gt;what&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The book ends with a project on building a multithreaded web server, which is
meant to solidify many of the concepts taught throughout the book. It's a great
way to close out a great book.&lt;/p&gt;
&lt;h1&gt;What I didn't like&lt;/h1&gt;
&lt;p&gt;This is my first book review where I can't come up with something that I overtly
did not like about a book. There are things the book lacks, such as more
beginner-friendly introductions to core programming concepts, but I feel that's
by design rather than thoughtless omission. The book would simply be way too
long if it had to include such things as well.&lt;/p&gt;
&lt;p&gt;Perhaps I will find something to be annoyed with as I revisit this in the
future, but as it stands I am completely pleased with my reading experience.&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;This is a great book to learn the Rust programming language. It's not
appropriate for absolute beginners, but I think that may be simply a consequence
of Rust being designed to tackle rather advanced problems. I would not
recommend a budding programmer to start out with Rust, and so it seems
completely natural to me that the official learning resource doesn't cater toward
such a crowd. That being said, you don't need to be a seasoned programmer
to get value out of this book, as concepts are explained with quite a lot of
"backstory". You don't need to be overly familiar with the problems Rust
attempts to solve (memory safety, for example) as the book clearly exemplifies
the problems before outlining the solutions.&lt;/p&gt;
&lt;p&gt;As &lt;em&gt;The Rust Programming Language&lt;/em&gt; is &lt;a href="https://doc.rust-lang.org/stable/book/"&gt;freely available
online&lt;/a&gt;, I whole-heartedly recommend it
for those looking to dive into Rust. I see no good reason to go looking
elsewhere for resources when there's such a great one staring you right in the
face. This is &lt;em&gt;the&lt;/em&gt; starting place for a prospective Rustacean!&lt;/p&gt;</content><category term="Reviews"></category><category term="book review"></category><category term="software engineering"></category><category term="rust"></category></entry><entry><title>Book Review: 97 Things Every Programmer Should Know</title><link href="https://slar.se/book-review-97-things.html" rel="alternate"></link><published>2022-07-11T21:00:48+02:00</published><updated>2022-07-11T21:00:48+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2022-07-11:/book-review-97-things.html</id><summary type="html">&lt;p&gt;&lt;em&gt;97 Things Every Programmer Should Know&lt;/em&gt; is a collection of short essays by
experienced programmers. And by short, I mean &lt;em&gt;short&lt;/em&gt;: 1-3 fairly tiny pages a
piece. If you're on a journey to become a software engineer then this book will
give you a crash course in terminology you should …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;97 Things Every Programmer Should Know&lt;/em&gt; is a collection of short essays by
experienced programmers. And by short, I mean &lt;em&gt;short&lt;/em&gt;: 1-3 fairly tiny pages a
piece. If you're on a journey to become a software engineer then this book will
give you a crash course in terminology you should be familiar with. Even as a
practicing software engineer there is wisdom to be found in this book, but a
novice will undoubtedly get more out of reading it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;97&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Things&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Every&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Programmer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Should&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Know&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Kevlin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Henney&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;Released&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;February&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2010&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;Publisher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;O&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Reilly&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Media&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Inc&lt;/span&gt;&lt;span class="mf"&gt;.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;ISBN&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9780596809485&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;The book in a nutshell&lt;/h1&gt;
&lt;p&gt;As I mentioned in the introduction, &lt;em&gt;97 Things Every Programmer Should Know&lt;/em&gt; is
a collection of very short essays by practicing professionals. The essays treat
a wide variety of themes that are relevant to a practicing software engineer,
ranging from hard technical skills such as the &lt;em&gt;Don't Repeat Yourself&lt;/em&gt; principle
and &lt;em&gt;Single Responsibility Principle&lt;/em&gt;, to softer skills such as interacting with
managers and fostering good relationships with your colleagues. Most of the
essays are focused on the technical side of things, however, and there is good
variety in the technical topics. While a lot of the essays are about how to
write good code, there is also a healthy amount of recommendations for tooling
to use, such as static code analysers, automated test suites, version control
systems and more.&lt;/p&gt;
&lt;p&gt;There really isn't much more to say regarding what the book is about. It's like
a collection of very well-written blog posts on programming-related topics. So
if you're reading this blog, chances are good you're going to enjoy this book.&lt;/p&gt;
&lt;h1&gt;What I liked&lt;/h1&gt;
&lt;p&gt;In some ways, &lt;em&gt;97 Things&lt;/em&gt; has a lot in common with &lt;a href="https://slar.se/book-review-apprenticeship-patterns.html"&gt;Apprenticeship
Patterns&lt;/a&gt; that I reviewed last week.
They're both about how you improve as a software engineer. The difference is
that &lt;em&gt;97 Things&lt;/em&gt; is a lot more to the point and more concrete. For the most
part, it presents tips and tricks that you can apply immediately and see
benefits from just as fast. For the budding software engineer, it's an excellent
pool of topics to diversify your skill set. That's with an emphasis on &lt;em&gt;topics&lt;/em&gt;,
though. This book presents a brief introduction to a wide variety of topics, but
it dives deeply into none of them. I think this is a great strength of the book,
as it means you will never get stuck on some "boring" topic that doesn't
interest you.&lt;/p&gt;
&lt;p&gt;While you can absolutely draw connections between the essays, they are written
as standalone pieces of work. This makes &lt;em&gt;97 Things&lt;/em&gt; a perfect book to read on
the go, when you might just have a few minutes or so to read.&lt;/p&gt;
&lt;p&gt;Out of all 97 things, I recall only a handful that I didn't find genuinely
helpful or insightful. Some essays even contradict each other, which actually
gives a nice perspective on the fact that a &lt;em&gt;lot&lt;/em&gt; of best practices are, to a
large degree, opinions. A notable example I recall is about automatic code
formatting, where one essay discourages its use and a few others encourage it.
I think this is a great benefit of having so many different authors. You don't
just get one person's opinion.&lt;/p&gt;
&lt;h1&gt;What I didn't like&lt;/h1&gt;
&lt;p&gt;As with many other books on how to be a good software engineer, there is a slight
tint of workaholism over some of the essays. I especially found an essay by
Robert C. Martin on what it means to be a professional programmer to send this
message. It's the same theme I found a little bit disturbing with
&lt;a href="https://slar.se/book-review-apprenticeship-patterns.html"&gt;Apprenticeship Patterns&lt;/a&gt;. I can't say I
disagree with the message; I truly believe in the craftsmanship approach to
software engineering, the path of lifelong learning. But at the same time I
don't think it is for everyone, and I think it should be possible to treat
programming as "just a job".&lt;/p&gt;
&lt;p&gt;A minor inconvenience is that the essays are ordered alphabetically, where I
would have preferred them to be ordered by theme. Finding a particular essay of
which you recall the theme but not the title is needlessly difficult. I just now
suffered through it trying to find the aforementioned essay by Robert C. Martin.&lt;/p&gt;
&lt;p&gt;But as a package, I find little to dislike about the book. Even the workaholism
part is effectively counteracted by an entire essay dedicated to sending the
message "work smarter not harder".&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;This is another book that I wish I'd read years ago. I strongly recommend it as
a read for &lt;em&gt;any&lt;/em&gt; software engineer at the beginning of their career or student
(self-taught or at a seat of learning) who is preparing for their career. Being
such a light and quick read, I find no good reason not to spend the few hours it
takes to read through the book and be exposed to a whole lot of different ideas.&lt;/p&gt;</content><category term="Reviews"></category><category term="book review"></category><category term="software engineering"></category></entry><entry><title>Book Review: Apprenticeship Patterns</title><link href="https://slar.se/book-review-apprenticeship-patterns.html" rel="alternate"></link><published>2022-07-02T13:00:48+02:00</published><updated>2022-07-02T13:27:48+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2022-07-02:/book-review-apprenticeship-patterns.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Apprenticeship Patterns: Guidance for the Aspiring Software Craftsman&lt;/em&gt; is
fundamentally a book about lifelong learning. It is about treating software
engineering as a craft you may never master; in fact it may never have been
mastered before. Perhaps it simply cannot be mastered in the traditional sense
of the word …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Apprenticeship Patterns: Guidance for the Aspiring Software Craftsman&lt;/em&gt; is
fundamentally a book about lifelong learning. It is about treating software
engineering as a craft you may never master; in fact it may never have been
mastered before. Perhaps it simply cannot be mastered in the traditional sense
of the word. But that doesn't mean that we should not aspire to master it, that
we should not embark on &lt;em&gt;The Long Road&lt;/em&gt;. So how can a book help with that?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;Apprenticeship&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Patterns&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Guidance&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Aspiring&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Software&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Craftsman&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Dave&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Hoover&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Adewale&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Oshineye&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;Released&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;October&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2009&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nv"&gt;Publisher&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;O&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;Reilly Media, Inc.&lt;/span&gt;
&lt;span class="err"&gt;ISBN: 9780596518387&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;The book in a nutshell&lt;/h1&gt;
&lt;p&gt;The core tenet of the book is that software engineering is a &lt;em&gt;craft&lt;/em&gt;. A craft in
the same sense that blacksmithing is, or carpentry, or the construction of
musical instruments. The authors provide a concise reasoning for why this is so.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Software engineering is a craft precisely because we don't understand it well
enough to make it a codified discipline like science or engineering.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;One can agree or disagree with this statement, but it is hard to argue against
the notion that software engineering is something that requires a high degree of
&lt;em&gt;skill&lt;/em&gt;. That's not skill as in technical proficiency, although that is part of
it. It's skill as in everything that encompasses a successful software engineer,
of which technical proficiency is important but far from being the skill in it's
own right.&lt;/p&gt;
&lt;p&gt;As the title suggests, &lt;em&gt;Apprenticeship Patterns&lt;/em&gt; is comprised of a series of
&lt;em&gt;patterns&lt;/em&gt;. These are meant to help you hone your skill as a software craftsman.
Each pattern is composed of four parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Context: A generalized context to put the pattern in perspective.&lt;/li&gt;
&lt;li&gt;Problem: A concrete problem statement.&lt;/li&gt;
&lt;li&gt;Solution: One or more suggestions for solving or alleviating the problem.&lt;/li&gt;
&lt;li&gt;Action: A concrete exercise to practice the solution.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The patterns are really &lt;em&gt;contextual habits&lt;/em&gt;; given a situation X it is
appropriate to do Y. A (perhaps &lt;em&gt;the&lt;/em&gt;) core pattern is &lt;em&gt;The Long Road&lt;/em&gt;, which
boils down to the fact that mastering a craft is a lifelong process. It
challenges the notion that the quickest way to success as measured in notoriety
or material wealth is what one should aspire for. The solution is a lengthy
affair, but it importantly suggests that climbing the corporate ladder through
quick promotions or similar easily takes you away from the actual crafting of
software, thus diverting you from The Long Road. You should be prepared to work
as a developer for many years to come. Many of the other patterns of the book
complement The Long Road, such as &lt;em&gt;Stay In The Trenches&lt;/em&gt; which specifically
deals with the problem of success being rewarded with promotions.&lt;/p&gt;
&lt;p&gt;Another pattern that struck home with me is &lt;em&gt;Record What You Learn&lt;/em&gt;. Quite
unsurprisingly, it simply suggests that one should keep a record of the things
you have learned and plan to learn in the future. This book review is in fact a
direct application of that pattern.&lt;/p&gt;
&lt;p&gt;There are many, many more patterns in the book. Some of my favorite ones include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Be The Worst&lt;/em&gt;: Place yourself in situations where you are surrounded by
  craftsmen that are more skilled than you in some area, and that you can learn
  from. Avoid becoming complacent.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Share What You Learn&lt;/em&gt;: Put your learning experiences out in the open, for
  anyone to find.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Kindred Spirits&lt;/em&gt;: Surround yourself with others passionate to learn the
  things you wish to dive into.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Use The Source&lt;/em&gt;: Read open source code. A lot.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Read Constantly&lt;/em&gt;: Read books. A lot.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm not going to list all the patterns that resonated with me, and I can't even
do these few ones justice with just this brief explanation of them. You really
need to read the book with each context, problem, solution and action for the
respective patterns to get the full picture.&lt;/p&gt;
&lt;h1&gt;What I liked&lt;/h1&gt;
&lt;p&gt;This book is a very easy read. I like to have at least one &lt;em&gt;soft&lt;/em&gt; book to read
when my mind wanders too much for me to take in a technical book, and
&lt;em&gt;Apprenticeship Patterns&lt;/em&gt; perfectly fits that bill. It took me a couple of weeks
with a few pages a night to get through it. It's easy to pick it up, read about
a pattern or two, and then put it down. It's well organized and easy to refer
back to after completion. The patterns are presented with just enough context to
make them understandable, yet the authors do not dwell on things for too long.
It is a concise book that is still easy to comprehend.&lt;/p&gt;
&lt;p&gt;I also found that it is a highly inspirational book, and approaching software
engineering as a craft really speaks to me. Many of the patterns of this book
are quite obvious to me and I practice several of them already, yet there are
many patterns I think I should practice that I don't. Record What You Learn is
the perfect example. I've been thinking for years that I should do so, but never
really got around to doing it other than a sporadic blog post once or twice a
year. After reading the book, I have newfound motivation to apply many of
the patterns, as this book review is tangible evidence of. In the future, I
intend to always finish up a book with a book review. Hopefully I will improve
in writing them with time, as I am not all that happy with how this review
turned out. But Share What You Learn tells me I should post this anyway, and I
really do agree with that.&lt;/p&gt;
&lt;p&gt;I also think this is a terrific book to read as a budding software engineer. It
is called &lt;em&gt;Apprenticeship Patterns&lt;/em&gt;, after all. I wish I would have read it
years ago, and I wish I was already practicing many of the patterns. But better
late than never, and as I will discuss in the next section there is a reason for
me to be somewhat thankful for not reading it earlier.&lt;/p&gt;
&lt;h1&gt;What I didn't like&lt;/h1&gt;
&lt;p&gt;While I think this is a good handbook for mastering a craft, I also think the
approach is potentially unhealthy if applied without moderation. I have
personally struggled a lot with finding a balance between improving my skills as
a software and just living a life separate from software engineering. Or
computers and technology in general. I found the book truly inspirational, so
much so that it prompted be to spend two hours of my Saturday morning writing
this book review. To be completely honest, I am still tweaking the
aforementioned balance. I would not say that I am struggling anymore, but I
cannot deny that it is still a work in progress.&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;This book struck home with me, and I wholeheartedly recommend it. But that is a
recommendation with a caveat, as I don't think this is a book for everyone.
It's really all in the title, this book is for the aspiring software
&lt;em&gt;craftsman&lt;/em&gt;. I don't think you &lt;em&gt;have&lt;/em&gt; to approach software engineering as a
craft that you devote yourself to, and the authors actually allude to this as
well. It's one approach, and it's a great boon to the field that some take it.
But for others, working with software can be "just a job", and not their
passion. That is fine, a job can be just a means to provide for yourself. And
if that's you, then I say skip this book. But if you do have a passion for
building great software, I think this is a book you don't want to miss.&lt;/p&gt;</content><category term="Reviews"></category><category term="book review"></category><category term="software engineering"></category></entry></feed>