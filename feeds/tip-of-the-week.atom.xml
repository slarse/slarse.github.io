<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>slar.se - Tip of the Week</title><link href="https://slar.se/" rel="alternate"></link><link href="https://slar.se/feeds/tip-of-the-week.atom.xml" rel="self"></link><id>https://slar.se/</id><updated>2019-06-11T23:16:00+02:00</updated><entry><title>I/O redirection in bash</title><link href="https://slar.se/io-redirection-in-bash.html" rel="alternate"></link><published>2019-06-11T23:16:00+02:00</published><updated>2019-06-11T23:16:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-06-11:/io-redirection-in-bash.html</id><summary type="html">&lt;p&gt;Alright, so Tip of the Week has turned somewhat into "tip every two or three
weeks". It turns out that it's pretty difficult to find the time to actually
write something every week. but I'll keep trying. With that out of the way,
let's head into the subject matter of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Alright, so Tip of the Week has turned somewhat into "tip every two or three
weeks". It turns out that it's pretty difficult to find the time to actually
write something every week. but I'll keep trying. With that out of the way,
let's head into the subject matter of this post: &lt;em&gt;I/O redirection&lt;/em&gt;. 
We'll just have a look at the most basic but also most generally applicable use
of redirection: taking the output from a program and storing it in a file.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; Files will both be created and clobbered in this TOTW. When
trying this stuff out, first create a new directory and do everything in
there, so you don't litter your filesystem with strange files, or
accidentally overwrite something important.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Redirecting output&lt;/h2&gt;
&lt;p&gt;To set the stage, I'll be working in a directory with the following contents:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls
file1.txt  file2.txt  image1.png file2.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Redirecting output is fairly simple, and useful when you want to save the
output of some command in a file. There are two primary ways of redirecting
output: &lt;em&gt;appending&lt;/em&gt; and &lt;em&gt;truncating&lt;/em&gt;. Appending is the one I use the most,
so let's start with that one.&lt;/p&gt;
&lt;h3&gt;Appending output redirection&lt;/h3&gt;
&lt;p&gt;With &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, we can make an appending redirect.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls &amp;gt;&amp;gt; ls_output.txt  &lt;span class="c1"&gt;# output from ls saved to output.txt&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ cat ls_output.txt    &lt;span class="c1"&gt;# let&amp;#39;s have a look... &lt;/span&gt;
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls &amp;gt;&amp;gt; ls_output.txt  &lt;span class="c1"&gt;# append new output&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ cat ls_output.txt    &lt;span class="c1"&gt;# let&amp;#39;s have a look again&lt;/span&gt;
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There are three things to note here. First, the &lt;code&gt;ls_output.txt&lt;/code&gt; file does not
exist in the initial directory, and so it is created with the first redirect.
Note however that &lt;code&gt;ls_output.txt&lt;/code&gt; is present in the first redirected output
from &lt;code&gt;ls&lt;/code&gt;: &lt;code&gt;ls_output.txt&lt;/code&gt; is actually created &lt;em&gt;before&lt;/em&gt; &lt;code&gt;ls&lt;/code&gt; is run as there
needs to be an open
&lt;a href="https://en.wikipedia.org/wiki/File_descriptor"&gt;file descriptor&lt;/a&gt;* to the file
pass along. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; * &lt;/strong&gt; A file descriptor can simply be thought of as a pointer to a file.
There is no need to understand file descriptors intimately to use basic I/O
redirection efficiently.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The second redirect is then appended to the file, which at that
point already exists. And that pretty much sums up how an appending redirect
functions: it appends output to the specified file if it exists, and creates a
file with the output if it does not exist. I find that this is most often the
functionality that I want, but in some cases, you want to re-create the file
from scratch with each redirect. That can be achieved with a truncating
redirect.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You may note that the output of &lt;code&gt;ls&lt;/code&gt; is formatted differently when
output to the terminal, and when redirected to a file. &lt;code&gt;ls&lt;/code&gt; checks whether
the stdout file descriptor points to a terminal, or something else, and
formats the output accordingly. The details are somewhat out of scope.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Truncating output redirection&lt;/h3&gt;
&lt;p&gt;Let's assume that we start over from the initial state of the directory, before
&lt;code&gt;ls_output.txt&lt;/code&gt; existed. We can then make a truncating redirect with &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ rm ls_output.txt    &lt;span class="c1"&gt;# restore initial directory state&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls &amp;gt; ls_output.txt  &lt;span class="c1"&gt;# make a truncating redirect&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ cat ls_output.txt   &lt;span class="c1"&gt;# and inspect the results&lt;/span&gt;
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls &amp;gt; ls_output.txt  &lt;span class="c1"&gt;# another truncating redirect&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ cat ls_output.txt
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you did not know what truncating meant before, you can probably figure it out
now. With a single &lt;code&gt;&amp;gt;&lt;/code&gt;, the specified file is created if it does not exist, just
like with &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, but it is entirely overwritten (truncated, clobbered) if it
already does exist. I rarely use a truncating redirect, as it is an easy thing
to accidentally truncate a file you did not mean to touch. I recommend to always
use an appending redirect, unless you have a good reason to truncate the
targeted file.&lt;/p&gt;
&lt;p&gt;And that's it for this TOTW!&lt;/p&gt;</content><category term="totw"></category><category term="bash"></category></entry><entry><title>Piping commands in bash</title><link href="https://slar.se/piping-commands-in-bash.html" rel="alternate"></link><published>2019-05-21T00:00:00+02:00</published><updated>2019-05-21T00:00:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-05-21:/piping-commands-in-bash.html</id><summary type="html">&lt;p&gt;Many, many bash commands are built around and meant to be used with a
fundamental feature of the bash shell (actually, most shells), called &lt;em&gt;piping&lt;/em&gt;.
Put simply, piping takes the output of one command and provides it as input to
the next. Here's a simple example of running &lt;code&gt;ls&lt;/code&gt; and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Many, many bash commands are built around and meant to be used with a
fundamental feature of the bash shell (actually, most shells), called &lt;em&gt;piping&lt;/em&gt;.
Put simply, piping takes the output of one command and provides it as input to
the next. Here's a simple example of running &lt;code&gt;ls&lt;/code&gt; and filtering the result with
&lt;code&gt;grep&lt;/code&gt; to find all &lt;code&gt;.py&lt;/code&gt; files in the current directory.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ls &lt;span class="c1"&gt;# just run ls &lt;/span&gt;
file1.md  file2.md  file3.md  script1.py  script2.py
$ ls &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s1"&gt;&amp;#39;\.py$&amp;#39;&lt;/span&gt;
script1.py
script2.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To be precise, the &lt;code&gt;|&lt;/code&gt; (pipe) operator takes the output from the command on the
left, and provides it as input to the command on the right. Pipes can be chained
practically as much as you'd like. For example, if we want to get amount of
&lt;code&gt;.py&lt;/code&gt; files in the current directory, we can pipe the output from &lt;code&gt;grep&lt;/code&gt; to the
&lt;code&gt;wc&lt;/code&gt; (word count) command, with the &lt;code&gt;-l&lt;/code&gt; option to count lines only.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ls &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s1"&gt;&amp;#39;\.py$&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; wc -l
&lt;span class="m"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;wc&lt;/code&gt; counts two lines, which is precisely the amount of &lt;code&gt;.py&lt;/code&gt; files that we
found. Let's move on to I/O redirection. Piping allows you to easily compose
powerful programs from simple commands, and is a very intuitive way to work.
Next week, I'll cover I/O redirection, which is another super useful feature of
bash that's a bit more complicated.&lt;/p&gt;</content><category term="totw"></category><category term="bash"></category></entry><entry><title>Using bash aliases</title><link href="https://slar.se/using-bash-aliases.html" rel="alternate"></link><published>2019-05-06T12:19:00+02:00</published><updated>2019-05-06T12:19:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-05-06:/using-bash-aliases.html</id><summary type="html">&lt;p&gt;For this &lt;em&gt;Tip of the Week&lt;/em&gt;, I'd like to present something that took me a while
to figure out why it was useful. That something is bash aliases, and I'll now
walk you through how to create aliases, and the two main ways in which I use
them (although I'm …&lt;/p&gt;</summary><content type="html">&lt;p&gt;For this &lt;em&gt;Tip of the Week&lt;/em&gt;, I'd like to present something that took me a while
to figure out why it was useful. That something is bash aliases, and I'll now
walk you through how to create aliases, and the two main ways in which I use
them (although I'm sure there are more use cases).&lt;/p&gt;
&lt;h1&gt;Using aliases&lt;/h1&gt;
&lt;p&gt;I think the &lt;code&gt;bash&lt;/code&gt; manpage has a very good and concise description of what an
alias is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Aliases allow a string to be substituted for a word when it is used as the
first word of a simple command&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In other words, I can define a command that is substituted for some other
command. Creating an alias is very simple. The syntax looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alias &amp;lt;NAME&amp;gt;=&amp;lt;COMMAND&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So for example, if I want to have a command &lt;code&gt;hellofile&lt;/code&gt; that creates a file with
the text "Hello, world!", I can achieve that with the following alias.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;alias&lt;/span&gt; &lt;span class="nv"&gt;hellofile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;echo &amp;quot;Hello, world!&amp;quot; &amp;gt; hellofile.txt&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note the single quotes around the command definition. Without them, &lt;code&gt;bash&lt;/code&gt;
would interpret the alias as being only &lt;code&gt;echo&lt;/code&gt;, and the rest of the line as
another command. Now, if I run the command &lt;code&gt;hellofile&lt;/code&gt;, it fill be substituted
with &lt;code&gt;echo "Hello, world!" &amp;gt; hellofile.txt&lt;/code&gt;. You should think of aliases as pure
text substitution: precisely what you put in the alias definition will be put on
the command line when you invoke it. You can view all of your current aliases
by running &lt;code&gt;alias&lt;/code&gt; without any options. Now, let's have a look at some common
use cases!&lt;/p&gt;
&lt;h2&gt;Specifying "default" options for commands&lt;/h2&gt;
&lt;p&gt;This is probably the most common use case for aliases, and it's likely that you
already have some in play. A common one is to have &lt;code&gt;ls&lt;/code&gt; aliased to &lt;code&gt;ls
--color=auto&lt;/code&gt;. That is to say, the following alias is defined:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;alias&lt;/span&gt; &lt;span class="nv"&gt;ls&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ls --color=auto&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So if I now run e.g. &lt;code&gt;ls /etc&lt;/code&gt;, the resulting command is actually &lt;code&gt;ls
--color=auto /etc&lt;/code&gt;. Note how the alias does not have to be the &lt;em&gt;only&lt;/em&gt; word I
type for the command, it just has to be the first one. Another command that I
use an alias for is &lt;code&gt;xclip&lt;/code&gt;, which is a small utility for copying stuff. I use
it almost exclusively to copy file contents to the clipboard, but that's not the
default functionality. In order to copy to the clipboard, I must write this
rather cumbersome command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ xclip -selection clipboard &amp;lt;FILEPATH&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So I have an alias for it so I can just type &lt;code&gt;xclip &amp;lt;FILEPATH&amp;gt;&lt;/code&gt; to copy to the
clipboard.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;alias&lt;/span&gt; &lt;span class="nv"&gt;xclip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;xclip -selection clipboard&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As a side note, it may not be the best style to clobber an existing command with
an alias, but I still tend to do that for some of my most commonly used
commands. If you want to use the vanilla command, simply put it within single
quotes, which will hinder the alias from expanding (e.g. type &lt;code&gt;'ls'&lt;/code&gt; to run &lt;code&gt;ls&lt;/code&gt;
without &lt;code&gt;--color=auto&lt;/code&gt;). Note that just defining an alias in a &lt;code&gt;bash&lt;/code&gt; session
will not persist: it needs to be defined anew for each session. To have it
permanently defined, put the definition in a startup script (e.g. &lt;code&gt;.bashrc&lt;/code&gt; or
&lt;code&gt;.bash_profile&lt;/code&gt;).&lt;/p&gt;
&lt;h2&gt;Creating throwaway commands&lt;/h2&gt;
&lt;p&gt;Now, the aliases I described above are useful to have defined permanently, and
should be defined in a startup script. The second use case I have for aliases is
when I have a repetitive command that I need to type over and over in the same
session, but isn't useful in general. An example would be when I need to run
some specific Java class in a project. Let's say I need to run the class
&lt;code&gt;se.slar.awesome.project.Main&lt;/code&gt; over and over. Instead of typing &lt;code&gt;java
se.slar.awesome.project.Main&lt;/code&gt; over and over, I define an alias for it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;alias&lt;/span&gt; &lt;span class="nv"&gt;runmain&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;java se.slar.awesome.project.Main&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And then, instead of writing all of that out, or having to do some
&lt;a href="https://slar.se/reverse-search-in-bash.html"&gt;reverse searching&lt;/a&gt; or
&lt;a href="https://slar.se/history-and-history-expansion-in-bash.html"&gt;history lookups&lt;/a&gt;, I can just type &lt;code&gt;runmain&lt;/code&gt;.
As defining an alias is so effortless, I tend to do it even if I know I'm just
gonna use the complex command a couple of times.&lt;/p&gt;
&lt;p&gt;And that's all I wanted to cover, hope you enjoyed it and stay tuned for the
next TOTW coming next week!&lt;/p&gt;</content><category term="totw"></category><category term="bash"></category></entry><entry><title>Git local</title><link href="https://slar.se/git-local.html" rel="alternate"></link><published>2019-04-29T22:58:00+02:00</published><updated>2019-04-29T22:58:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-04-29:/git-local.html</id><summary type="html">&lt;p&gt;Nowadays, Git is almost ubiquitous in software development. Most developers also
know that Git is a &lt;em&gt;decentralized&lt;/em&gt; version control system, meaning that every
copy of the repository carries the full revision history, and there is no
"central" repository. A consequence of the decentralized aspect of Git is that
you can …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Nowadays, Git is almost ubiquitous in software development. Most developers also
know that Git is a &lt;em&gt;decentralized&lt;/em&gt; version control system, meaning that every
copy of the repository carries the full revision history, and there is no
"central" repository. A consequence of the decentralized aspect of Git is that
you can create repositories locally, and version control documents in them
locally, without ever setting up a remote repository on e.g. GitHub or GitLab.
In this TOTW, I'll show you how to use Git locally, and also how to change your
mind and put it on e.g. GitHub at a later time.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This also touches on an important and often misunderstood point: Git
and GitHub are &lt;em&gt;not&lt;/em&gt; the same thing. Git is a version control system, while
GitHub is a service which allows hosting of remote repositories, issue
management etc. GitHub is also not the only service around,
&lt;a href="https://gitlab.com"&gt;GitLab&lt;/a&gt; and &lt;a href="https://bitbucket.com"&gt;BitBucket&lt;/a&gt; are two
other prominent services which host Git repositories.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Using Git locally&lt;/h3&gt;
&lt;p&gt;How do you use Git locally, then? It's simple. Just create a directory and run
&lt;code&gt;git init&lt;/code&gt; to initialize it as a Git repository. Here's an example command line
session of what it looks like.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;~&lt;span class="o"&gt;]&lt;/span&gt; $ mkdir repo
&lt;span class="o"&gt;[&lt;/span&gt;~&lt;span class="o"&gt;]&lt;/span&gt; $ &lt;span class="nb"&gt;cd&lt;/span&gt; repo
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ ls -a
. ..            &lt;span class="c1"&gt;# repo is empty&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git init
Initialized empty Git repository in /home/slarse/repo/.git/
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ ls -a
.  ..  .git     &lt;span class="c1"&gt;# the .git directory indicates that this is now a Git repo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I often use Git to version control stuff that I have no intention of ever
putting up in a remote repository. This is useful for when you accidentally
remove stuff, or just need to try out a bunch of different ideas that you can
swap back and forth between by simply switching branches.&lt;/p&gt;
&lt;h3&gt;Changing your mind (also called adding a remote)&lt;/h3&gt;
&lt;p&gt;If you suddenly feel like that local repo should be put up on a hosting service
after all, maybe just to back it up, or maybe to collaborate with someone else,
it's very simple to do so. First, create an empty repository (as in completely
empty, don't initialize it with a README or license). Then copy the address to
the repository (I prefer to use SSH). Let's say I have a repo at
&lt;code&gt;git@github.com:slarse/superrepo.git&lt;/code&gt;. I can then add it as a remote to my local
repo, and push my master branch to it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git remote add origin git@github.com:slarse/superrepo.git
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git branch
* master  &lt;span class="c1"&gt;# I&amp;#39;m on the master branch, which is what I want to push&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git push --set-upstream origin master
Enumerating objects: &lt;span class="m"&gt;3&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Counting objects: &lt;span class="m"&gt;100&lt;/span&gt;% &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;/3&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Writing objects: &lt;span class="m"&gt;100&lt;/span&gt;% &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;/3&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="m"&gt;213&lt;/span&gt; bytes &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;213&lt;/span&gt;.00 KiB/s, &lt;span class="k"&gt;done&lt;/span&gt;.
Total &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;delta &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, reused &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;delta &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
To github.com:slarse/superrepo.git
 * &lt;span class="o"&gt;[&lt;/span&gt;new branch&lt;span class="o"&gt;]&lt;/span&gt;      master -&amp;gt; master
Branch &lt;span class="s1"&gt;&amp;#39;master&amp;#39;&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt; up to track remote branch &lt;span class="s1"&gt;&amp;#39;master&amp;#39;&lt;/span&gt; from &lt;span class="s1"&gt;&amp;#39;origin&amp;#39;&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now my previously local-only repo is also in GitHub, and I can push and pull
from it as usual. That's all for this tip of the week, it's just meant to spark
an idea that took me quite a while to come up with myself!&lt;/p&gt;</content><category term="totw"></category><category term="bash"></category><category term="git"></category></entry><entry><title>History and history expansion in bash</title><link href="https://slar.se/history-and-history-expansion-in-bash.html" rel="alternate"></link><published>2019-04-22T11:59:00+02:00</published><updated>2019-04-22T11:59:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-04-22:/history-and-history-expansion-in-bash.html</id><summary type="html">&lt;p&gt;Admittedly, this TOTW is one day late, so this week there will be 2xTOTW! In
any case, the tip I want to bring up here is very much related to last week's
TOTW on &lt;a href="https://slar.se/reverse-search-in-bash.html"&gt;Reverse search in bash&lt;/a&gt;. Sometimes,
reverse searching just doesn't work out. You may not be quite …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Admittedly, this TOTW is one day late, so this week there will be 2xTOTW! In
any case, the tip I want to bring up here is very much related to last week's
TOTW on &lt;a href="https://slar.se/reverse-search-in-bash.html"&gt;Reverse search in bash&lt;/a&gt;. Sometimes,
reverse searching just doesn't work out. You may not be quite sure what you
are looking for, or there are just too many recent commands that look samey.
In such cases, using the &lt;code&gt;history&lt;/code&gt; command is a good alternative. &lt;/p&gt;
&lt;h3&gt;&lt;code&gt;history&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;history&lt;/code&gt; command will display the last commands that you have entered, and
looks something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;history&lt;/span&gt;
 &lt;span class="m"&gt;1009&lt;/span&gt;  &lt;span class="nb"&gt;fg&lt;/span&gt;
 &lt;span class="m"&gt;1010&lt;/span&gt;  git status
 &lt;span class="m"&gt;1011&lt;/span&gt;  git commit -a -m &lt;span class="s1"&gt;&amp;#39;Add module docstring to github_api module&amp;#39;&lt;/span&gt;
 &lt;span class="o"&gt;[&lt;/span&gt;***OUTPUT TRUNCATED***&lt;span class="o"&gt;]&lt;/span&gt;
 &lt;span class="m"&gt;2007&lt;/span&gt;  &lt;span class="nb"&gt;history&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Each command is called an &lt;em&gt;event&lt;/em&gt;, and the output is formatted as &lt;code&gt;&amp;lt;event_nr&amp;gt;
&amp;lt;event&amp;gt;&lt;/code&gt;. Precisely how many commands are returned by the &lt;code&gt;history&lt;/code&gt; is
determined by the &lt;code&gt;HISTSIZE&lt;/code&gt; and &lt;code&gt;HISTFILESIZE&lt;/code&gt; environment variables. Setting
these to something like &lt;code&gt;5000&lt;/code&gt; and &lt;code&gt;10000&lt;/code&gt;, respectively, should be manageable
even for the weakest of computers. You can also limit the output of &lt;code&gt;history&lt;/code&gt;
by providing an integer argument, so e.g. &lt;code&gt;history 5&lt;/code&gt; will display the last 5
commands. Now, the real power of &lt;code&gt;history&lt;/code&gt; becomes apparent when using it
with &lt;em&gt;history expansion&lt;/em&gt;.&lt;/p&gt;
&lt;h3&gt;History expansion&lt;/h3&gt;
&lt;p&gt;History expansion can be used to expand an event number into the whole command
it corresponds to. To expand an event, one simply types &lt;code&gt;!&amp;lt;event_nr&amp;gt;&lt;/code&gt;. For
example, looking at the &lt;code&gt;history&lt;/code&gt; output above I can see that event number 1010
corresponds to &lt;code&gt;git status&lt;/code&gt;. I can execute the command again with history
expansion like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ !1010
git status         &lt;span class="c1"&gt;# Command is echoed&lt;/span&gt;
On branch master   &lt;span class="c1"&gt;# Output from executing the command&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;***REST OF OUTPUT OMITTED***&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The command is first echoed, and then executed. There are a few other ways to
specify the event number.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt;: Execute the last event.&lt;ul&gt;
&lt;li&gt;I.e. type &lt;code&gt;!!&lt;/code&gt; in the terminal.&lt;/li&gt;
&lt;li&gt;Can be useful to re-execute a command that you realized you needed &lt;code&gt;sudo&lt;/code&gt;
  for with &lt;code&gt;sudo !!&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;: Execute the nth previous event.&lt;ul&gt;
&lt;li&gt;E.g. type &lt;code&gt;!-1&lt;/code&gt; to execute the last event, &lt;code&gt;!-2&lt;/code&gt; to execute the one
  before that, and so on.&lt;/li&gt;
&lt;li&gt;I personally don't find this very useful.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is one more very useful feature that I often use, and that is the ability
to only print the command. This can be achieved by appending &lt;code&gt;:p&lt;/code&gt; to the
history expansion command. Here is an example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ !1011:p
git commit -a -m &lt;span class="s1"&gt;&amp;#39;Add module docstring to github_api module&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The command can then be accessed by pressing UP-arrow or &lt;code&gt;ctrl-p&lt;/code&gt;, which is
very useful if you need to do minor modifications to it. There are tons of
more ways to use history expansion, and I strongly recommend reading the man-page
on it. Type &lt;code&gt;man bash&lt;/code&gt; and then search for &lt;code&gt;HISTORY EXPANSION&lt;/code&gt;, or do the same
in &lt;a href="https://linux.die.net/man/1/bash"&gt;this online bash man page&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Filtering history&lt;/h3&gt;
&lt;p&gt;A final tip on using history expansion is to filter the output with &lt;code&gt;grep&lt;/code&gt;. For
example, if I only want to find commands that include the word &lt;code&gt;git&lt;/code&gt;, I can
filter the output of &lt;code&gt;history&lt;/code&gt; by &lt;em&gt;piping&lt;/em&gt; to &lt;code&gt;grep&lt;/code&gt; with the &lt;code&gt;|&lt;/code&gt; character.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;history&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep git
 &lt;span class="m"&gt;1010&lt;/span&gt;  git status
 &lt;span class="m"&gt;1011&lt;/span&gt;  git commit -a -m &lt;span class="s1"&gt;&amp;#39;Add module docstring to github_api module&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I will most likely do another TOTW on piping, but the basic principle is that
&lt;code&gt;|&lt;/code&gt; takes the output from the command on the left and feeds it as input to the
command on the right. That's it for this TOTW, stay tuned for the next one
coming on Sunday the 28th of April!&lt;/p&gt;</content><category term="totw"></category><category term="bash"></category></entry><entry><title>Reverse search in bash</title><link href="https://slar.se/reverse-search-in-bash.html" rel="alternate"></link><published>2019-04-09T23:23:00+02:00</published><updated>2019-04-09T23:23:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-04-09:/reverse-search-in-bash.html</id><summary type="html">&lt;p&gt;Have you ever found yourself furiously tapping the UP-arrow (or &lt;code&gt;ctrl+p&lt;/code&gt;) to
find a command that's probably waaaay up there? Would you be surprised if I
told you there's a better way? When you want to re-use a command you've written
previously, and you know it's not the previous …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Have you ever found yourself furiously tapping the UP-arrow (or &lt;code&gt;ctrl+p&lt;/code&gt;) to
find a command that's probably waaaay up there? Would you be surprised if I
told you there's a better way? When you want to re-use a command you've written
previously, and you know it's not the previous command, or the one before that,
your first resort should be a &lt;em&gt;reverse search&lt;/em&gt;. This can be accessed with
&lt;code&gt;ctrl+r&lt;/code&gt;. If you press that button combination, you should see something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;reverse-i-search&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;: 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Just start typing the beginning of the command you're looking for, and most
often, it will pop up. For example, I sometimes need to re-run the
previous&lt;code&gt;git&lt;/code&gt; command that I ran a while back. I then press &lt;code&gt;ctrl+r&lt;/code&gt; and type
&lt;code&gt;git&lt;/code&gt; to get something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;reverse-i-search&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;git&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;: git push
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note how the initial &lt;code&gt;git&lt;/code&gt; before the &lt;code&gt;:&lt;/code&gt; is what I've actually written here,
and the text after the &lt;code&gt;:&lt;/code&gt; (in this case &lt;code&gt;git push&lt;/code&gt;) is what's been found with
the reverse search. Pressing &lt;code&gt;tab&lt;/code&gt; now will terminate the search and put the
result of the search on the command line for editing. Then, simply press
&lt;code&gt;enter&lt;/code&gt; to execute the command as usual. You can also skip over the editing
part and press &lt;code&gt;enter&lt;/code&gt; right away to execute the command as-is. Sometimes,
however, the result you get first isn't what you want (obviously, just typing
&lt;code&gt;git push&lt;/code&gt; would have been faster in this case).  You can then press &lt;code&gt;ctrl+r&lt;/code&gt;
again to cycle to the next hit.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(reverse-i-search)`git&amp;#39;: git commit -a -m &amp;#39;Add module docstring to github_api module&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now there's a command that I might not want to have to type out again in its
entirety, better showing why a reverse search may be useful. That's it for this
week's TotW, check back next week for more!&lt;/p&gt;</content><category term="totw"></category><category term="bash"></category></entry><entry><title>Announcing Tip of the Week (TotW)</title><link href="https://slar.se/announcing-tip-of-the-week-totw.html" rel="alternate"></link><published>2019-04-09T23:15:00+02:00</published><updated>2019-04-09T23:15:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-04-09:/announcing-tip-of-the-week-totw.html</id><summary type="html">&lt;p&gt;In order to actually get around to writing some content, I've decided to start
a little series: Tip of the Week! Every week, I'll spend 30 minutes or so
writing a very small article about some tip related to programming, Linux or
technology in general. And no, this one does …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In order to actually get around to writing some content, I've decided to start
a little series: Tip of the Week! Every week, I'll spend 30 minutes or so
writing a very small article about some tip related to programming, Linux or
technology in general. And no, this one does not count, so I still have to
write this week's TotW!&lt;/p&gt;</content><category term="totw"></category></entry></feed>