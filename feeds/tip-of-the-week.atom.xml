<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Programming for fun and profit - Tip of the Week</title><link href="https://slar.se/" rel="alternate"></link><link href="https://slar.se/feeds/tip-of-the-week.atom.xml" rel="self"></link><id>https://slar.se/</id><updated>2019-07-22T22:01:00+02:00</updated><subtitle>A blog about software engineering, programming languages and technical tinkering</subtitle><entry><title>Git worktrees: work in parallel on multiple versions of a project</title><link href="https://slar.se/git-worktrees-work-in-parallel-on-multiple-versions-of-a-project.html" rel="alternate"></link><published>2019-07-22T22:01:00+02:00</published><updated>2019-07-22T22:01:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-07-22:/git-worktrees-work-in-parallel-on-multiple-versions-of-a-project.html</id><summary type="html">&lt;p&gt;I've been AWOL for a month due to injury, sickness and conference-going. But
with all that finally out of the way, I have another Tip of the Week, this time
relating to Git: the &lt;code&gt;git worktree&lt;/code&gt; command. With &lt;code&gt;git worktree&lt;/code&gt;, you can check
out &lt;em&gt;multiple&lt;/em&gt; branches at once, which is …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've been AWOL for a month due to injury, sickness and conference-going. But
with all that finally out of the way, I have another Tip of the Week, this time
relating to Git: the &lt;code&gt;git worktree&lt;/code&gt; command. With &lt;code&gt;git worktree&lt;/code&gt;, you can check
out &lt;em&gt;multiple&lt;/em&gt; branches at once, which is super useful for when working on major
changes where you need to view multiple versions, or maybe you're just trying a
few different solutions to a single prodlem. If you've ever found yourself
frantically switching branches, stashing changes to be able to switch branches,
and even creating copies of the repository you're working in, then this article
is for you.&lt;/p&gt;
&lt;h3&gt;An example repo&lt;/h3&gt;
&lt;p&gt;Let's first create an example repo. Here's a little terminal session where I
create a repository, add a README to it on the master branch, add another line
to the readme on a branch called other, and finally checking out to master.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;~&lt;span class="o"&gt;]&lt;/span&gt; $ mkdir repo
&lt;span class="o"&gt;[&lt;/span&gt;~&lt;span class="o"&gt;]&lt;/span&gt; $ &lt;span class="nb"&gt;cd&lt;/span&gt; repo
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git init
Initialized empty Git repository &lt;span class="k"&gt;in&lt;/span&gt; /home/slarse/repo/.git/
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello!&amp;quot;&lt;/span&gt; &amp;gt; README.md
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git add README.md &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git commit -m &lt;span class="s1"&gt;&amp;#39;Add README&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;master &lt;span class="o"&gt;(&lt;/span&gt;root-commit&lt;span class="o"&gt;)&lt;/span&gt; 6094baf&lt;span class="o"&gt;]&lt;/span&gt; Add README
 &lt;span class="m"&gt;1&lt;/span&gt; file changed, &lt;span class="m"&gt;1&lt;/span&gt; insertion&lt;span class="o"&gt;(&lt;/span&gt;+&lt;span class="o"&gt;)&lt;/span&gt;
 create mode &lt;span class="m"&gt;100644&lt;/span&gt; README.md
&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git checkout -b other
Switched to a new branch &lt;span class="s1"&gt;&amp;#39;other&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;other&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;There!&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; README.md 
&lt;span class="o"&gt;(&lt;/span&gt;other&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git commit -am &lt;span class="s1"&gt;&amp;#39;Add new line to README&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;other b779dfb&lt;span class="o"&gt;]&lt;/span&gt; Add new line to README
 &lt;span class="m"&gt;1&lt;/span&gt; file changed, &lt;span class="m"&gt;1&lt;/span&gt; insertion&lt;span class="o"&gt;(&lt;/span&gt;+&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;other&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git checkout master
Switched to branch &lt;span class="s1"&gt;&amp;#39;master&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It's not super important how you do it, just make sure to have two branches.&lt;/p&gt;
&lt;h3&gt;Adding a new worktree&lt;/h3&gt;
&lt;p&gt;First of all: what is a &lt;em&gt;worktree&lt;/em&gt;? Usually, you only have &lt;em&gt;the&lt;/em&gt; worktree, which
is the part of a repository where you actually do your work (edit files etc).
Running &lt;code&gt;git worktree list&lt;/code&gt; on most repos will show the location of this single
worktree, and what commit/branch it is checked out to.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ &lt;span class="nb"&gt;pwd&lt;/span&gt; &lt;span class="c1"&gt;# just checking the current working directory&lt;/span&gt;
/home/slarse/repo
&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git worktree list
/home/slarse/repo  6094baf &lt;span class="o"&gt;[&lt;/span&gt;master&lt;span class="o"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;# points to the cwd, checked out to master&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; When I run &lt;code&gt;git worktree list&lt;/code&gt; after this point, it's just to show
the results of commands.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With &lt;code&gt;git worktree add&lt;/code&gt;, you can add additional worktrees checked out to
different commits. The most basic usage is &lt;code&gt;git worktree add &amp;lt;path&amp;gt;
&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, where &lt;code&gt;path&lt;/code&gt; is a path to the new worktree (i.e. where you want
to put it), and &lt;code&gt;commit-ish&lt;/code&gt; is something like a commit or branch (or a few
other things that are not important for every-day use). Let's check out &lt;code&gt;other&lt;/code&gt;
in a new worktree. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git worktree add ../repo-other other
Preparing worktree &lt;span class="o"&gt;(&lt;/span&gt;checking out &lt;span class="s1"&gt;&amp;#39;other&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
HEAD is now at b779dfb Add new line to README
&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git worktree list
/home/slarse/repo        6094baf &lt;span class="o"&gt;[&lt;/span&gt;master&lt;span class="o"&gt;]&lt;/span&gt;
/home/slarse/repo-other  b779dfb &lt;span class="o"&gt;[&lt;/span&gt;other&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ ls -a ../repo-other &lt;span class="c1"&gt;# have a look in the new working tree&lt;/span&gt;
.  ..  .git  README.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you can see, the new worktree has been created, and can be seen in the list
of worktrees. &lt;code&gt;.git&lt;/code&gt; is usually a directory, but in the case of a non-primary
worktree, it's actually just a file with a path to the original &lt;code&gt;.git&lt;/code&gt;
directory.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ cat ../repo-other/.git 
gitdir: /home/slarse/repo/.git/worktrees/repo-other
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Like many things in Git, it's brilliantly simple. You can start working in your
new worktree like it's an entirely separate repository, with the caveat that you
can't check out to a branch that is checked out in some other worktree. That
includes checking out to other commits or branches, and even creating entirely
new branches.&lt;/p&gt;
&lt;h3&gt;Moving a worktree&lt;/h3&gt;
&lt;p&gt;If for some reason you need to move a worktree, you should use &lt;code&gt;git worktree
move&lt;/code&gt; to make sure that all of the references are correctly changed. It's very
simple, just type &lt;code&gt;git worktree move &amp;lt;src&amp;gt; &amp;lt;dst&amp;gt;&lt;/code&gt;. For example, if I want to
move &lt;code&gt;../repo-other&lt;/code&gt; to &lt;code&gt;../repo-work&lt;/code&gt;, I do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git worktree move ../repo-other ../repo-work
&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git worktree list
/home/slarse/repo       6094baf &lt;span class="o"&gt;[&lt;/span&gt;master&lt;span class="o"&gt;]&lt;/span&gt;
/home/slarse/repo-work  b779dfb &lt;span class="o"&gt;[&lt;/span&gt;other&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's all there is to moving worktrees. Not very exciting, and I can't recall
ever actually doing it, but I can see how it could be useful.&lt;/p&gt;
&lt;h3&gt;Removing a worktree&lt;/h3&gt;
&lt;p&gt;To remove a worktree, run &lt;code&gt;git worktree remove &amp;lt;path&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git worktree remove ../repo-work/
&lt;span class="o"&gt;(&lt;/span&gt;master&lt;span class="o"&gt;)[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git worktree list
/home/slarse/repo  6094baf &lt;span class="o"&gt;[&lt;/span&gt;master&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can also just remove the directory with the worktree and the reference to it
will be removed automatically (but not necessarily immediately). Run &lt;code&gt;git
worktree prune&lt;/code&gt; to trigger this removal process.&lt;/p&gt;
&lt;h3&gt;The other worktree commands&lt;/h3&gt;
&lt;p&gt;There are a few more &lt;code&gt;git worktree&lt;/code&gt; commands that I've never felt the need to
use. Have a look at them
&lt;a href="https://git-scm.com/docs/git-worktree"&gt;in the git-worktree documentation&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;In this short article I showcased &lt;code&gt;git worktree&lt;/code&gt;. It's super useful to work in
parallel on different versions of the same project, without having to create
copies of the repository and thereby having to deal with synchronizing multiple
local copies (which can quickly get hard to manage). I find myself using this
more and more, and if you find it useful yourself I highly recommend reading up
on it more in its man-page (either with &lt;code&gt;man git-worktree&lt;/code&gt; or
&lt;a href="https://git-scm.com/docs/git-worktree"&gt;online&lt;/a&gt;).&lt;/p&gt;</content><category term="Tip of the Week"></category><category term="totw"></category><category term="bash"></category><category term="git"></category></entry><entry><title>Redirecting stdout and stderr in bash</title><link href="https://slar.se/redirecting-stdout-and-stderr-in-bash.html" rel="alternate"></link><published>2019-06-23T21:37:00+02:00</published><updated>2019-06-23T21:37:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-06-23:/redirecting-stdout-and-stderr-in-bash.html</id><summary type="html">&lt;p&gt;A couple of weeks ago I covered some basic I/O redirection in bash (see
&lt;a href="https://slar.se/io-redirection-in-bash.html"&gt;I/O redirection in bash&lt;/a&gt;). Well, there's actually
a lot more to it, so for this TOTW I thought I'd touch on a few more advanced
usages.&lt;/p&gt;
&lt;h2&gt;Redirecting stderr&lt;/h2&gt;
&lt;p&gt;Sometimes, you may find that part …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A couple of weeks ago I covered some basic I/O redirection in bash (see
&lt;a href="https://slar.se/io-redirection-in-bash.html"&gt;I/O redirection in bash&lt;/a&gt;). Well, there's actually
a lot more to it, so for this TOTW I thought I'd touch on a few more advanced
usages.&lt;/p&gt;
&lt;h2&gt;Redirecting stderr&lt;/h2&gt;
&lt;p&gt;Sometimes, you may find that part or all of the output of a command isn't
properly redirected. As a quick example, navigate to any directory that is &lt;em&gt;not&lt;/em&gt;
a Git repository, and run &lt;code&gt;git status&lt;/code&gt;. You should see something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git status
fatal: not a git repository &lt;span class="o"&gt;(&lt;/span&gt;or any of the parent directories&lt;span class="o"&gt;)&lt;/span&gt;: .git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Yet, if you try to redirect it with a standard redirect, the output
is still displayed, and the file you redirect to remains empty.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git status &amp;gt; output
fatal: not a git repository &lt;span class="o"&gt;(&lt;/span&gt;or any of the parent directories&lt;span class="o"&gt;)&lt;/span&gt;: .git
$ cat output
$ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The reason is quite simple: the output from &lt;code&gt;git status&lt;/code&gt; is an error message,
which is typically output on &lt;em&gt;standard error&lt;/em&gt; (stderr), while I/O redirection
operates on &lt;em&gt;standard output&lt;/em&gt; (stdout) by default. When redirecting output (or
input, for that matter), one can optionally provide a file descriptor specifying
which output stream to redirect. On a typical UNIX-like system, stdout is file
descriptor 1, and stderr is file descriptor 2. So if we want to catch that
stderr output, we just need to prepend  a 2 to the redirection operator.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git status &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt; output
$ cat output
fatal: not a git repository &lt;span class="o"&gt;(&lt;/span&gt;or any of the parent directories&lt;span class="o"&gt;)&lt;/span&gt;: .git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can probably guess that if you leave the file descriptor out, it will
default to 1. In some cases, you may want to redirect both stderr and stdout to
the same file. But many programs output both on stderr and stdout, and we may
want to redirect both of them.&lt;/p&gt;
&lt;h2&gt;Redirecting stderr and stdout&lt;/h2&gt;
&lt;p&gt;So, we can specify a file descriptor to redirect stdout or stderr (or any other
file descriptor, really), but many programs output on both stderr and stdout,
and it's often useful to redirect both. Here's a small Python script &lt;code&gt;print.py&lt;/code&gt;
that outputs on line on stdout and one on stderr.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;some standard output&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;some error output&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; That's Python as in Python 3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If we redirect stdout only, then the stderr line is still printed to the
terminal.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python3 print.py &lt;span class="m"&gt;1&lt;/span&gt;&amp;gt; stdout_output &lt;span class="c1"&gt;# recall that the 1 can be omitted&lt;/span&gt;
some error output
$ cat stdout_output
some standard output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Similarly, redirecting only stderr leaves the stdout output on the terminal.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python3 print.py &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt; stderr_output
some standard output
$ cat stderr_output
some error output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Quite intuitively, if we want to redirect both stderr and stdout to one file
each, we can simply do two redirections following one another.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python3 print.py &lt;span class="m"&gt;1&lt;/span&gt;&amp;gt; stdout_output &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt; stderr_output
$ cat stdout_output
some standard output
$ cat stderr_output
some error output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There's also the possibility to redirect both stdout and stderr to the same file
using the special &lt;code&gt;&amp;amp;&lt;/code&gt; character in place of a file descriptor.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python3 print.py &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&amp;gt; output
$ cat output
some standard output
some error output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And with that and the previous article, I've shared pretty much everything I
feel is useful with output redirection. In some future Tip of the Week, I'm sure
I'll get into input redirecton as well, as it's much the same.&lt;/p&gt;</content><category term="Tip of the Week"></category><category term="totw"></category><category term="bash"></category></entry><entry><title>Technical e-books from Humble Bundle</title><link href="https://slar.se/technical-e-books-from-humble-bundle.html" rel="alternate"></link><published>2019-06-13T09:12:00+02:00</published><updated>2019-06-13T09:12:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-06-13:/technical-e-books-from-humble-bundle.html</id><summary type="html">&lt;p&gt;Another Tip of the Week, in the same week as the previous one (because I've
been slacking off). This one is very simple, and rather non-technical. I simply
want to direct attention toward
&lt;a href="https://www.humblebundle.com/"&gt;humblebundle.com&lt;/a&gt;, and their quite frequent book
bundles. Many of these book bundles include or are entirely …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Another Tip of the Week, in the same week as the previous one (because I've
been slacking off). This one is very simple, and rather non-technical. I simply
want to direct attention toward
&lt;a href="https://www.humblebundle.com/"&gt;humblebundle.com&lt;/a&gt;, and their quite frequent book
bundles. Many of these book bundles include or are entirely centered around
programming topics. I've gotten tons of great books from there over the years,
and it can really pay off to keep an eye on the new bundles. Typically, the top
tier of a book bundle is around 15-20 EUR, while most books in it cost more
alone. There have been general programming bundles, hacking/security bundles,
Python bundles (a lot of them), Linux bundles, and much more. A few of the best
books I've gotten from Humble include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Linux-Programming-Interface-System-Handbook/dp/1593272200"&gt;The Linux Programming Interface&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Got it in a 20 EUR bundle, while this book alone costs somewhere around 70.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Fluent-Python-Concise-Effective-Programming-dp-1491946008/dp/1491946008/ref=mt_paperback?_encoding=UTF8&amp;amp;me=&amp;amp;qid="&gt;Fluent Python&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;I actually already owned this book at the time of acquiring it from a
  bundle, but it's by far the best book on Python I've ever read.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Flask-Web-Development-Developing-Applications-dp-1491991739/dp/1491991739/ref=mt_paperback?_encoding=UTF8&amp;amp;me=&amp;amp;qid=1560410372"&gt;Flask Web Development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/CSS-Definitive-Guide-Visual-Presentation-dp-1449393195/dp/1449393195/ref=mt_paperback?_encoding=UTF8&amp;amp;me=&amp;amp;qid=1560410482"&gt;CSS: The Definitive Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And many, many more! Really, all I want to get said with this TOTW is that you
should really keep an eye on Humble Bundle, as their book bundles contain
tremendous value, and you can choose to put some (or all) of the money you pay
toward charity. And that's all there is to it!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; I am not sponsored by Humble in any way, I am simply a
long-time user of the service.&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="Tip of the Week"></category><category term="totw"></category></entry><entry><title>I/O redirection in bash</title><link href="https://slar.se/io-redirection-in-bash.html" rel="alternate"></link><published>2019-06-11T23:16:00+02:00</published><updated>2019-06-11T23:16:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-06-11:/io-redirection-in-bash.html</id><summary type="html">&lt;p&gt;Alright, so Tip of the Week has turned somewhat into "tip every two or three
weeks". It turns out that it's pretty difficult to find the time to actually
write something every week. but I'll keep trying. With that out of the way,
let's head into the subject matter of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Alright, so Tip of the Week has turned somewhat into "tip every two or three
weeks". It turns out that it's pretty difficult to find the time to actually
write something every week. but I'll keep trying. With that out of the way,
let's head into the subject matter of this post: &lt;em&gt;I/O redirection&lt;/em&gt;. 
We'll just have a look at the most basic but also most generally applicable use
of redirection: taking the output from a program and storing it in a file.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; Files will both be created and clobbered in this TOTW. When
trying this stuff out, first create a new directory and do everything in
there, so you don't litter your filesystem with strange files, or
accidentally overwrite something important.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Redirecting output&lt;/h2&gt;
&lt;p&gt;To set the stage, I'll be working in a directory with the following contents:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls
file1.txt  file2.txt  image1.png file2.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Redirecting output is fairly simple, and useful when you want to save the
output of some command in a file. There are two primary ways of redirecting
output: &lt;em&gt;appending&lt;/em&gt; and &lt;em&gt;truncating&lt;/em&gt;. Appending is the one I use the most,
so let's start with that one.&lt;/p&gt;
&lt;h3&gt;Appending output redirection&lt;/h3&gt;
&lt;p&gt;With &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, we can make an appending redirect.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls &amp;gt;&amp;gt; ls_output.txt  &lt;span class="c1"&gt;# output from ls saved to output.txt&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ cat ls_output.txt    &lt;span class="c1"&gt;# let&amp;#39;s have a look... &lt;/span&gt;
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls &amp;gt;&amp;gt; ls_output.txt  &lt;span class="c1"&gt;# append new output&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ cat ls_output.txt    &lt;span class="c1"&gt;# let&amp;#39;s have a look again&lt;/span&gt;
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There are three things to note here. First, the &lt;code&gt;ls_output.txt&lt;/code&gt; file does not
exist in the initial directory, and so it is created with the first redirect.
Note however that &lt;code&gt;ls_output.txt&lt;/code&gt; is present in the first redirected output
from &lt;code&gt;ls&lt;/code&gt;: &lt;code&gt;ls_output.txt&lt;/code&gt; is actually created &lt;em&gt;before&lt;/em&gt; &lt;code&gt;ls&lt;/code&gt; is run as there
needs to be an open
&lt;a href="https://en.wikipedia.org/wiki/File_descriptor"&gt;file descriptor&lt;/a&gt;* to the file
pass along. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; * &lt;/strong&gt; A file descriptor can simply be thought of as a pointer to a file.
There is no need to understand file descriptors intimately to use basic I/O
redirection efficiently.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The second redirect is then appended to the file, which at that
point already exists. And that pretty much sums up how an appending redirect
functions: it appends output to the specified file if it exists, and creates a
file with the output if it does not exist. I find that this is most often the
functionality that I want, but in some cases, you want to re-create the file
from scratch with each redirect. That can be achieved with a truncating
redirect.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You may note that the output of &lt;code&gt;ls&lt;/code&gt; is formatted differently when
output to the terminal, and when redirected to a file. &lt;code&gt;ls&lt;/code&gt; checks whether
the stdout file descriptor points to a terminal, or something else, and
formats the output accordingly. The details are somewhat out of scope.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Truncating output redirection&lt;/h3&gt;
&lt;p&gt;Let's assume that we start over from the initial state of the directory, before
&lt;code&gt;ls_output.txt&lt;/code&gt; existed. We can then make a truncating redirect with &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ rm ls_output.txt    &lt;span class="c1"&gt;# restore initial directory state&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls &amp;gt; ls_output.txt  &lt;span class="c1"&gt;# make a truncating redirect&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ cat ls_output.txt   &lt;span class="c1"&gt;# and inspect the results&lt;/span&gt;
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ ls &amp;gt; ls_output.txt  &lt;span class="c1"&gt;# another truncating redirect&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;tmp&lt;span class="o"&gt;]&lt;/span&gt; $ cat ls_output.txt
file1.txt
file2.txt
image1.png
image2.png
ls_output.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you did not know what truncating meant before, you can probably figure it out
now. With a single &lt;code&gt;&amp;gt;&lt;/code&gt;, the specified file is created if it does not exist, just
like with &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, but it is entirely overwritten (truncated, clobbered) if it
already does exist. I rarely use a truncating redirect, as it is an easy thing
to accidentally truncate a file you did not mean to touch. I recommend to always
use an appending redirect, unless you have a good reason to truncate the
targeted file.&lt;/p&gt;
&lt;p&gt;And that's it for this TOTW!&lt;/p&gt;</content><category term="Tip of the Week"></category><category term="totw"></category><category term="bash"></category></entry><entry><title>Piping commands in bash</title><link href="https://slar.se/piping-commands-in-bash.html" rel="alternate"></link><published>2019-05-21T00:00:00+02:00</published><updated>2019-05-21T00:00:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-05-21:/piping-commands-in-bash.html</id><summary type="html">&lt;p&gt;Many, many bash commands are built around and meant to be used with a
fundamental feature of the bash shell (actually, most shells), called &lt;em&gt;piping&lt;/em&gt;.
Put simply, piping takes the output of one command and provides it as input to
the next. Here's a simple example of running &lt;code&gt;ls&lt;/code&gt; and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Many, many bash commands are built around and meant to be used with a
fundamental feature of the bash shell (actually, most shells), called &lt;em&gt;piping&lt;/em&gt;.
Put simply, piping takes the output of one command and provides it as input to
the next. Here's a simple example of running &lt;code&gt;ls&lt;/code&gt; and filtering the result with
&lt;code&gt;grep&lt;/code&gt; to find all &lt;code&gt;.py&lt;/code&gt; files in the current directory.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls &lt;span class="c1"&gt;# just run ls &lt;/span&gt;
file1.md  file2.md  file3.md  script1.py  script2.py
$ ls &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s1"&gt;&amp;#39;\.py$&amp;#39;&lt;/span&gt;
script1.py
script2.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To be precise, the &lt;code&gt;|&lt;/code&gt; (pipe) operator takes the output from the command on the
left, and provides it as input to the command on the right. Pipes can be chained
practically as much as you'd like. For example, if we want to get amount of
&lt;code&gt;.py&lt;/code&gt; files in the current directory, we can pipe the output from &lt;code&gt;grep&lt;/code&gt; to the
&lt;code&gt;wc&lt;/code&gt; (word count) command, with the &lt;code&gt;-l&lt;/code&gt; option to count lines only.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s1"&gt;&amp;#39;\.py$&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; wc -l
&lt;span class="m"&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;wc&lt;/code&gt; counts two lines, which is precisely the amount of &lt;code&gt;.py&lt;/code&gt; files that we
found. Let's move on to I/O redirection. Piping allows you to easily compose
powerful programs from simple commands, and is a very intuitive way to work.
Next week, I'll cover I/O redirection, which is another super useful feature of
bash that's a bit more complicated.&lt;/p&gt;</content><category term="Tip of the Week"></category><category term="totw"></category><category term="bash"></category></entry><entry><title>Using bash aliases</title><link href="https://slar.se/using-bash-aliases.html" rel="alternate"></link><published>2019-05-06T12:19:00+02:00</published><updated>2019-05-06T12:19:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-05-06:/using-bash-aliases.html</id><summary type="html">&lt;p&gt;For this &lt;em&gt;Tip of the Week&lt;/em&gt;, I'd like to present something that took me a while
to figure out why it was useful. That something is bash aliases, and I'll now
walk you through how to create aliases, and the two main ways in which I use
them (although I'm …&lt;/p&gt;</summary><content type="html">&lt;p&gt;For this &lt;em&gt;Tip of the Week&lt;/em&gt;, I'd like to present something that took me a while
to figure out why it was useful. That something is bash aliases, and I'll now
walk you through how to create aliases, and the two main ways in which I use
them (although I'm sure there are more use cases).&lt;/p&gt;
&lt;h1&gt;Using aliases&lt;/h1&gt;
&lt;p&gt;I think the &lt;code&gt;bash&lt;/code&gt; manpage has a very good and concise description of what an
alias is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Aliases allow a string to be substituted for a word when it is used as the
first word of a simple command&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In other words, I can define a command that is substituted for some other
command. Creating an alias is very simple. The syntax looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;alias &amp;lt;NAME&amp;gt;=&amp;lt;COMMAND&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So for example, if I want to have a command &lt;code&gt;hellofile&lt;/code&gt; that creates a file with
the text "Hello, world!", I can achieve that with the following alias.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ &lt;span class="nb"&gt;alias&lt;/span&gt; &lt;span class="nv"&gt;hellofile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;echo &amp;quot;Hello, world!&amp;quot; &amp;gt; hellofile.txt&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note the single quotes around the command definition. Without them, &lt;code&gt;bash&lt;/code&gt;
would interpret the alias as being only &lt;code&gt;echo&lt;/code&gt;, and the rest of the line as
another command. Now, if I run the command &lt;code&gt;hellofile&lt;/code&gt;, it fill be substituted
with &lt;code&gt;echo "Hello, world!" &amp;gt; hellofile.txt&lt;/code&gt;. You should think of aliases as pure
text substitution: precisely what you put in the alias definition will be put on
the command line when you invoke it. You can view all of your current aliases
by running &lt;code&gt;alias&lt;/code&gt; without any options. Now, let's have a look at some common
use cases!&lt;/p&gt;
&lt;h2&gt;Specifying "default" options for commands&lt;/h2&gt;
&lt;p&gt;This is probably the most common use case for aliases, and it's likely that you
already have some in play. A common one is to have &lt;code&gt;ls&lt;/code&gt; aliased to &lt;code&gt;ls
--color=auto&lt;/code&gt;. That is to say, the following alias is defined:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ &lt;span class="nb"&gt;alias&lt;/span&gt; &lt;span class="nv"&gt;ls&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ls --color=auto&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So if I now run e.g. &lt;code&gt;ls /etc&lt;/code&gt;, the resulting command is actually &lt;code&gt;ls
--color=auto /etc&lt;/code&gt;. Note how the alias does not have to be the &lt;em&gt;only&lt;/em&gt; word I
type for the command, it just has to be the first one. Another command that I
use an alias for is &lt;code&gt;xclip&lt;/code&gt;, which is a small utility for copying stuff. I use
it almost exclusively to copy file contents to the clipboard, but that's not the
default functionality. In order to copy to the clipboard, I must write this
rather cumbersome command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ xclip -selection clipboard &amp;lt;FILEPATH&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So I have an alias for it so I can just type &lt;code&gt;xclip &amp;lt;FILEPATH&amp;gt;&lt;/code&gt; to copy to the
clipboard.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ &lt;span class="nb"&gt;alias&lt;/span&gt; &lt;span class="nv"&gt;xclip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;xclip -selection clipboard&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As a side note, it may not be the best style to clobber an existing command with
an alias, but I still tend to do that for some of my most commonly used
commands. If you want to use the vanilla command, simply put it within single
quotes, which will hinder the alias from expanding (e.g. type &lt;code&gt;'ls'&lt;/code&gt; to run &lt;code&gt;ls&lt;/code&gt;
without &lt;code&gt;--color=auto&lt;/code&gt;). Note that just defining an alias in a &lt;code&gt;bash&lt;/code&gt; session
will not persist: it needs to be defined anew for each session. To have it
permanently defined, put the definition in a startup script (e.g. &lt;code&gt;.bashrc&lt;/code&gt; or
&lt;code&gt;.bash_profile&lt;/code&gt;).&lt;/p&gt;
&lt;h2&gt;Creating throwaway commands&lt;/h2&gt;
&lt;p&gt;Now, the aliases I described above are useful to have defined permanently, and
should be defined in a startup script. The second use case I have for aliases is
when I have a repetitive command that I need to type over and over in the same
session, but isn't useful in general. An example would be when I need to run
some specific Java class in a project. Let's say I need to run the class
&lt;code&gt;se.slar.awesome.project.Main&lt;/code&gt; over and over. Instead of typing &lt;code&gt;java
se.slar.awesome.project.Main&lt;/code&gt; over and over, I define an alias for it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ &lt;span class="nb"&gt;alias&lt;/span&gt; &lt;span class="nv"&gt;runmain&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;java se.slar.awesome.project.Main&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And then, instead of writing all of that out, or having to do some
&lt;a href="https://slar.se/reverse-search-in-bash.html"&gt;reverse searching&lt;/a&gt; or
&lt;a href="https://slar.se/history-and-history-expansion-in-bash.html"&gt;history lookups&lt;/a&gt;, I can just type &lt;code&gt;runmain&lt;/code&gt;.
As defining an alias is so effortless, I tend to do it even if I know I'm just
gonna use the complex command a couple of times.&lt;/p&gt;
&lt;p&gt;And that's all I wanted to cover, hope you enjoyed it and stay tuned for the
next TOTW coming next week!&lt;/p&gt;</content><category term="Tip of the Week"></category><category term="totw"></category><category term="bash"></category></entry><entry><title>Git local</title><link href="https://slar.se/git-local.html" rel="alternate"></link><published>2019-04-29T22:58:00+02:00</published><updated>2019-04-29T22:58:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-04-29:/git-local.html</id><summary type="html">&lt;p&gt;Nowadays, Git is almost ubiquitous in software development. Most developers also
know that Git is a &lt;em&gt;decentralized&lt;/em&gt; version control system, meaning that every
copy of the repository carries the full revision history, and there is no
"central" repository. A consequence of the decentralized aspect of Git is that
you can …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Nowadays, Git is almost ubiquitous in software development. Most developers also
know that Git is a &lt;em&gt;decentralized&lt;/em&gt; version control system, meaning that every
copy of the repository carries the full revision history, and there is no
"central" repository. A consequence of the decentralized aspect of Git is that
you can create repositories locally, and version control documents in them
locally, without ever setting up a remote repository on e.g. GitHub or GitLab.
In this TOTW, I'll show you how to use Git locally, and also how to change your
mind and put it on e.g. GitHub at a later time.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This also touches on an important and often misunderstood point: Git
and GitHub are &lt;em&gt;not&lt;/em&gt; the same thing. Git is a version control system, while
GitHub is a service which allows hosting of remote repositories, issue
management etc. GitHub is also not the only service around,
&lt;a href="https://gitlab.com"&gt;GitLab&lt;/a&gt; and &lt;a href="https://bitbucket.com"&gt;BitBucket&lt;/a&gt; are two
other prominent services which host Git repositories.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Using Git locally&lt;/h3&gt;
&lt;p&gt;How do you use Git locally, then? It's simple. Just create a directory and run
&lt;code&gt;git init&lt;/code&gt; to initialize it as a Git repository. Here's an example command line
session of what it looks like.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;~&lt;span class="o"&gt;]&lt;/span&gt; $ mkdir repo
&lt;span class="o"&gt;[&lt;/span&gt;~&lt;span class="o"&gt;]&lt;/span&gt; $ &lt;span class="nb"&gt;cd&lt;/span&gt; repo
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ ls -a
. ..            &lt;span class="c1"&gt;# repo is empty&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git init
Initialized empty Git repository &lt;span class="k"&gt;in&lt;/span&gt; /home/slarse/repo/.git/
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ ls -a
.  ..  .git     &lt;span class="c1"&gt;# the .git directory indicates that this is now a Git repo&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I often use Git to version control stuff that I have no intention of ever
putting up in a remote repository. This is useful for when you accidentally
remove stuff, or just need to try out a bunch of different ideas that you can
swap back and forth between by simply switching branches.&lt;/p&gt;
&lt;h3&gt;Changing your mind (also called adding a remote)&lt;/h3&gt;
&lt;p&gt;If you suddenly feel like that local repo should be put up on a hosting service
after all, maybe just to back it up, or maybe to collaborate with someone else,
it's very simple to do so. First, create an empty repository (as in completely
empty, don't initialize it with a README or license). Then copy the address to
the repository (I prefer to use SSH). Let's say I have a repo at
&lt;code&gt;git@github.com:slarse/superrepo.git&lt;/code&gt;. I can then add it as a remote to my local
repo, and push my master branch to it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git remote add origin git@github.com:slarse/superrepo.git
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git branch
* master  &lt;span class="c1"&gt;# I&amp;#39;m on the master branch, which is what I want to push&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;repo&lt;span class="o"&gt;]&lt;/span&gt; $ git push --set-upstream origin master
Enumerating objects: &lt;span class="m"&gt;3&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Counting objects: &lt;span class="m"&gt;100&lt;/span&gt;% &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;/3&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Writing objects: &lt;span class="m"&gt;100&lt;/span&gt;% &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;/3&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="m"&gt;213&lt;/span&gt; bytes &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;213&lt;/span&gt;.00 KiB/s, &lt;span class="k"&gt;done&lt;/span&gt;.
Total &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;delta &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, reused &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;delta &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
To github.com:slarse/superrepo.git
 * &lt;span class="o"&gt;[&lt;/span&gt;new branch&lt;span class="o"&gt;]&lt;/span&gt;      master -&amp;gt; master
Branch &lt;span class="s1"&gt;&amp;#39;master&amp;#39;&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt; up to track remote branch &lt;span class="s1"&gt;&amp;#39;master&amp;#39;&lt;/span&gt; from &lt;span class="s1"&gt;&amp;#39;origin&amp;#39;&lt;/span&gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now my previously local-only repo is also in GitHub, and I can push and pull
from it as usual. That's all for this tip of the week, it's just meant to spark
an idea that took me quite a while to come up with myself!&lt;/p&gt;</content><category term="Tip of the Week"></category><category term="totw"></category><category term="bash"></category><category term="git"></category></entry><entry><title>History and history expansion in bash</title><link href="https://slar.se/history-and-history-expansion-in-bash.html" rel="alternate"></link><published>2019-04-22T11:59:00+02:00</published><updated>2019-04-22T11:59:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-04-22:/history-and-history-expansion-in-bash.html</id><summary type="html">&lt;p&gt;Admittedly, this TOTW is one day late, so this week there will be 2xTOTW! In
any case, the tip I want to bring up here is very much related to last week's
TOTW on &lt;a href="https://slar.se/reverse-search-in-bash.html"&gt;Reverse search in bash&lt;/a&gt;. Sometimes,
reverse searching just doesn't work out. You may not be quite …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Admittedly, this TOTW is one day late, so this week there will be 2xTOTW! In
any case, the tip I want to bring up here is very much related to last week's
TOTW on &lt;a href="https://slar.se/reverse-search-in-bash.html"&gt;Reverse search in bash&lt;/a&gt;. Sometimes,
reverse searching just doesn't work out. You may not be quite sure what you
are looking for, or there are just too many recent commands that look samey.
In such cases, using the &lt;code&gt;history&lt;/code&gt; command is a good alternative. &lt;/p&gt;
&lt;h3&gt;&lt;code&gt;history&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;history&lt;/code&gt; command will display the last commands that you have entered, and
looks something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ &lt;span class="nb"&gt;history&lt;/span&gt;
 &lt;span class="m"&gt;1009&lt;/span&gt;  &lt;span class="nb"&gt;fg&lt;/span&gt;
 &lt;span class="m"&gt;1010&lt;/span&gt;  git status
 &lt;span class="m"&gt;1011&lt;/span&gt;  git commit -a -m &lt;span class="s1"&gt;&amp;#39;Add module docstring to github_api module&amp;#39;&lt;/span&gt;
 &lt;span class="o"&gt;[&lt;/span&gt;***OUTPUT TRUNCATED***&lt;span class="o"&gt;]&lt;/span&gt;
 &lt;span class="m"&gt;2007&lt;/span&gt;  &lt;span class="nb"&gt;history&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Each command is called an &lt;em&gt;event&lt;/em&gt;, and the output is formatted as &lt;code&gt;&amp;lt;event_nr&amp;gt;
&amp;lt;event&amp;gt;&lt;/code&gt;. Precisely how many commands are returned by the &lt;code&gt;history&lt;/code&gt; is
determined by the &lt;code&gt;HISTSIZE&lt;/code&gt; and &lt;code&gt;HISTFILESIZE&lt;/code&gt; environment variables. Setting
these to something like &lt;code&gt;5000&lt;/code&gt; and &lt;code&gt;10000&lt;/code&gt;, respectively, should be manageable
even for the weakest of computers. You can also limit the output of &lt;code&gt;history&lt;/code&gt;
by providing an integer argument, so e.g. &lt;code&gt;history 5&lt;/code&gt; will display the last 5
commands. Now, the real power of &lt;code&gt;history&lt;/code&gt; becomes apparent when using it
with &lt;em&gt;history expansion&lt;/em&gt;.&lt;/p&gt;
&lt;h3&gt;History expansion&lt;/h3&gt;
&lt;p&gt;History expansion can be used to expand an event number into the whole command
it corresponds to. To expand an event, one simply types &lt;code&gt;!&amp;lt;event_nr&amp;gt;&lt;/code&gt;. For
example, looking at the &lt;code&gt;history&lt;/code&gt; output above I can see that event number 1010
corresponds to &lt;code&gt;git status&lt;/code&gt;. I can execute the command again with history
expansion like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ !1010
git status         &lt;span class="c1"&gt;# Command is echoed&lt;/span&gt;
On branch master   &lt;span class="c1"&gt;# Output from executing the command&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;***REST OF OUTPUT OMITTED***&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The command is first echoed, and then executed. There are a few other ways to
specify the event number.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt;: Execute the last event.&lt;ul&gt;
&lt;li&gt;I.e. type &lt;code&gt;!!&lt;/code&gt; in the terminal.&lt;/li&gt;
&lt;li&gt;Can be useful to re-execute a command that you realized you needed &lt;code&gt;sudo&lt;/code&gt;
  for with &lt;code&gt;sudo !!&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;: Execute the nth previous event.&lt;ul&gt;
&lt;li&gt;E.g. type &lt;code&gt;!-1&lt;/code&gt; to execute the last event, &lt;code&gt;!-2&lt;/code&gt; to execute the one
  before that, and so on.&lt;/li&gt;
&lt;li&gt;I personally don't find this very useful.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is one more very useful feature that I often use, and that is the ability
to only print the command. This can be achieved by appending &lt;code&gt;:p&lt;/code&gt; to the
history expansion command. Here is an example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ !1011:p
git commit -a -m &lt;span class="s1"&gt;&amp;#39;Add module docstring to github_api module&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The command can then be accessed by pressing UP-arrow or &lt;code&gt;ctrl-p&lt;/code&gt;, which is
very useful if you need to do minor modifications to it. There are tons of
more ways to use history expansion, and I strongly recommend reading the man-page
on it. Type &lt;code&gt;man bash&lt;/code&gt; and then search for &lt;code&gt;HISTORY EXPANSION&lt;/code&gt;, or do the same
in &lt;a href="https://linux.die.net/man/1/bash"&gt;this online bash man page&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Filtering history&lt;/h3&gt;
&lt;p&gt;A final tip on using history expansion is to filter the output with &lt;code&gt;grep&lt;/code&gt;. For
example, if I only want to find commands that include the word &lt;code&gt;git&lt;/code&gt;, I can
filter the output of &lt;code&gt;history&lt;/code&gt; by &lt;em&gt;piping&lt;/em&gt; to &lt;code&gt;grep&lt;/code&gt; with the &lt;code&gt;|&lt;/code&gt; character.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ &lt;span class="nb"&gt;history&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep git
 &lt;span class="m"&gt;1010&lt;/span&gt;  git status
 &lt;span class="m"&gt;1011&lt;/span&gt;  git commit -a -m &lt;span class="s1"&gt;&amp;#39;Add module docstring to github_api module&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I will most likely do another TOTW on piping, but the basic principle is that
&lt;code&gt;|&lt;/code&gt; takes the output from the command on the left and feeds it as input to the
command on the right. That's it for this TOTW, stay tuned for the next one
coming on Sunday the 28th of April!&lt;/p&gt;</content><category term="Tip of the Week"></category><category term="totw"></category><category term="bash"></category></entry><entry><title>Reverse search in bash</title><link href="https://slar.se/reverse-search-in-bash.html" rel="alternate"></link><published>2019-04-09T23:23:00+02:00</published><updated>2019-04-09T23:23:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-04-09:/reverse-search-in-bash.html</id><summary type="html">&lt;p&gt;Have you ever found yourself furiously tapping the UP-arrow (or &lt;code&gt;ctrl+p&lt;/code&gt;) to
find a command that's probably waaaay up there? Would you be surprised if I
told you there's a better way? When you want to re-use a command you've written
previously, and you know it's not the previous …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Have you ever found yourself furiously tapping the UP-arrow (or &lt;code&gt;ctrl+p&lt;/code&gt;) to
find a command that's probably waaaay up there? Would you be surprised if I
told you there's a better way? When you want to re-use a command you've written
previously, and you know it's not the previous command, or the one before that,
your first resort should be a &lt;em&gt;reverse search&lt;/em&gt;. This can be accessed with
&lt;code&gt;ctrl+r&lt;/code&gt;. If you press that button combination, you should see something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;reverse-i-search&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;: 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Just start typing the beginning of the command you're looking for, and most
often, it will pop up. For example, I sometimes need to re-run the
previous&lt;code&gt;git&lt;/code&gt; command that I ran a while back. I then press &lt;code&gt;ctrl+r&lt;/code&gt; and type
&lt;code&gt;git&lt;/code&gt; to get something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;reverse-i-search&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;git&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;: git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note how the initial &lt;code&gt;git&lt;/code&gt; before the &lt;code&gt;:&lt;/code&gt; is what I've actually written here,
and the text after the &lt;code&gt;:&lt;/code&gt; (in this case &lt;code&gt;git push&lt;/code&gt;) is what's been found with
the reverse search. Pressing &lt;code&gt;tab&lt;/code&gt; now will terminate the search and put the
result of the search on the command line for editing. Then, simply press
&lt;code&gt;enter&lt;/code&gt; to execute the command as usual. You can also skip over the editing
part and press &lt;code&gt;enter&lt;/code&gt; right away to execute the command as-is. Sometimes,
however, the result you get first isn't what you want (obviously, just typing
&lt;code&gt;git push&lt;/code&gt; would have been faster in this case).  You can then press &lt;code&gt;ctrl+r&lt;/code&gt;
again to cycle to the next hit.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(reverse-i-search)`git&amp;#39;: git commit -a -m &amp;#39;Add module docstring to github_api module&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now there's a command that I might not want to have to type out again in its
entirety, better showing why a reverse search may be useful. That's it for this
week's TotW, check back next week for more!&lt;/p&gt;</content><category term="Tip of the Week"></category><category term="totw"></category><category term="bash"></category></entry><entry><title>Announcing Tip of the Week (TotW)</title><link href="https://slar.se/announcing-tip-of-the-week-totw.html" rel="alternate"></link><published>2019-04-09T23:15:00+02:00</published><updated>2019-04-09T23:15:00+02:00</updated><author><name>Simon Larsén</name></author><id>tag:slar.se,2019-04-09:/announcing-tip-of-the-week-totw.html</id><summary type="html">&lt;p&gt;In order to actually get around to writing some content, I've decided to start
a little series: Tip of the Week! Every week, I'll spend 30 minutes or so
writing a very small article about some tip related to programming, Linux or
technology in general. And no, this one does …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In order to actually get around to writing some content, I've decided to start
a little series: Tip of the Week! Every week, I'll spend 30 minutes or so
writing a very small article about some tip related to programming, Linux or
technology in general. And no, this one does not count, so I still have to
write this week's TotW!&lt;/p&gt;</content><category term="Tip of the Week"></category><category term="totw"></category></entry></feed>